# -*- coding: utf-8 -*-
"""Final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G2tsDabMitU2UgI8UkyxhkR97UaaOn_b
"""


import dash
from dash import dcc, html, Input, Output, State, ctx, dash_table
import dash_bootstrap_components as dbc
import sqlite3
import yfinance as yf
from pypfopt.expected_returns import mean_historical_return
from pypfopt.risk_models import CovarianceShrinkage
from pypfopt.efficient_frontier import EfficientFrontier
import plotly.graph_objects as go
import plotly.express as px
import pandas as pd
import numpy as np  # <-- added

# ---------- Robust price helpers ----------
def fetch_price_matrix(tickers, period="1y", interval="1d"):
    """
    Fetch Close prices per ticker using yfinance.Ticker.history(auto_adjust=True).
    Returns a clean DataFrame (index=dates, columns=tickers).
    Works for single or multiple tickers and avoids 'Adj Close' KeyErrors.
    """
    tickers = [t.strip().upper() for t in tickers if t and str(t).strip()]
    frames = []
    for t in tickers:
        try:
            h = yf.Ticker(t).history(period=period, interval=interval, auto_adjust=True)
            if not h.empty and "Close" in h:
                frames.append(h["Close"].rename(t))
            else:
                # fallback to download with auto_adjust if history() is empty
                d = yf.download(t, period=period, interval=interval, auto_adjust=True, progress=False)
                if isinstance(d, pd.DataFrame) and "Close" in d.columns and not d["Close"].empty:
                    frames.append(d["Close"].rename(t))
        except Exception as e:
            print(f"[yfinance] {t}: {e}")
            continue

    if not frames:
        return pd.DataFrame()

    df = pd.concat(frames, axis=1).sort_index()
    # Fill tiny gaps and drop any rows still NaN
    df = df.ffill().dropna(how="all").dropna()
    return df

# Initialize and configure the database
def init_db():
    conn = sqlite3.connect('portfolio_data.db')
    c = conn.cursor()
    c.execute('DROP TABLE IF EXISTS holdings')
    c.execute('''
        CREATE TABLE IF NOT EXISTS portfolios (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL
        );
    ''')
    c.execute('''
        CREATE TABLE IF NOT EXISTS holdings (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            portfolio_id INTEGER,
            ticker TEXT NOT NULL,
            shares REAL NOT NULL,
            industry TEXT,
            value REAL,
            current_price REAL,
            weight REAL,
            FOREIGN KEY (portfolio_id) REFERENCES portfolios(id)
        );
    ''')
    conn.commit()
    conn.close()

init_db()

# Initialize the Dash app with Bootstrap styling
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])
server = app.server

# Layout of the application with tabbed interface
app.layout = dbc.Container([
    dcc.Tabs(id="tabs", children=[
        dcc.Tab(label='Create Portfolio', children=[
            html.Div([
                dbc.Input(id='portfolio-name', placeholder='Enter portfolio name', type='text'),
                dbc.Button('Create Portfolio', id='create-portfolio-btn', n_clicks=0, className="mt-2"),
                html.Div(id='portfolio-create-output', className="mt-2"),
            ]),
        ]),
        dcc.Tab(label='Add Holdings', children=[
            html.Div([
                dcc.Dropdown(id='portfolio-dropdown', placeholder='Select a portfolio'),
                dbc.Input(id='ticker-symbol', placeholder='Enter ticker symbol', type='text', className="mt-2"),
                dbc.Input(id='shares-amount', placeholder='Enter number of shares', type='number', className="mt-2"),
                dbc.Button('Add Holding', id='add-holding-btn', n_clicks=0, className="mt-2"),
                html.Div(id='holding-add-output', className="mt-2"),
                dash_table.DataTable(id='holdings-table',
                                     columns=[
                                         {'name': 'Industry', 'id': 'industry'},
                                         {'name': 'Ticker', 'id': 'ticker'},
                                         {'name': 'Shares', 'id': 'shares'},
                                         {'name': 'Current Price ($)', 'id': 'current_price'},
                                         {'name': 'Value ($)', 'id': 'value'},
                                         {'name': 'Weight (%)', 'id': 'weight'}
                                     ]),
                html.Div(id='total-portfolio-value', style={'marginTop': '20px'})
            ]),
        ]),
        dcc.Tab(label='Portfolio Optimization', children=[
            html.Div([
                dbc.Row([
                    dbc.Col([
                        html.Label("Select Risk Level:"),
                        dcc.Slider(
                            id='risk-slider',
                            min=0.10, max=0.50, step=0.05, value=0.20,
                            marks={0.10: 'Low', 0.30: 'Medium', 0.50: 'High'}
                        )
                    ], width=6)
                ]),
                dbc.Button('Optimize Portfolio', id='optimize-portfolio-btn', n_clicks=0, className="mt-2 mb-3"),
                dbc.Row([
                    dbc.Col([
                        html.Div([
                            html.H5("Current Portfolio Weights"),
                            html.Div(id='current-weights'),
                            dcc.Graph(id='current-allocation-chart', style={'height': '300px'}),
                        ])
                    ], width=6),
                    dbc.Col([
                        html.Div([
                            html.H5("Optimized Portfolio Weights"),
                            html.Div(id='optimization-results'),
                            dcc.Graph(id='allocation-chart', style={'height': '300px'}),
                        ])
                    ], width=6),
                ]),
                html.Div([
                    html.H5("Portfolio Performance Comparison"),
                    dcc.Graph(id='performance-comparison-chart', style={'height': '400px'}),
                ]),
            ]),
        ]),
    ]),
], fluid=True)


@app.callback(
    Output('portfolio-create-output', 'children'),
    Input('create-portfolio-btn', 'n_clicks'),
    State('portfolio-name', 'value')
)
def create_portfolio(n_clicks, name):
    if n_clicks > 0 and name:
        conn = sqlite3.connect('portfolio_data.db')
        c = conn.cursor()
        c.execute("INSERT INTO portfolios (name) VALUES (?)", (name,))
        conn.commit()
        conn.close()
        return dbc.Alert(f"Portfolio '{name}' created successfully!", color="success")
    return ""

@app.callback(
    Output('portfolio-dropdown', 'options'),
    Input('create-portfolio-btn', 'n_clicks'),
    State('portfolio-name', 'value'),
    prevent_initial_call=True
)
def update_portfolio_dropdown(n_clicks, name):
    conn = sqlite3.connect('portfolio_data.db')
    c = conn.cursor()
    portfolios = c.execute("SELECT id, name FROM portfolios").fetchall()
    conn.close()
    return [{'label': name, 'value': id} for id, name in portfolios]

@app.callback(
    [Output('holding-add-output', 'children'),
     Output('holdings-table', 'data'),
     Output('total-portfolio-value', 'children')],
    Input('add-holding-btn', 'n_clicks'),
    [State('portfolio-dropdown', 'value'),
     State('ticker-symbol', 'value'),
     State('shares-amount', 'value')],
    prevent_initial_call=True
)
def add_holding(n_clicks, portfolio_id, ticker, shares):
    if not portfolio_id:
        return "Please select a valid portfolio.", [], ""
    if not ticker or not shares:
        return "Please enter both ticker symbol and number of shares.", [], ""
    try:
        t = str(ticker).strip().upper()
        stock = yf.Ticker(t)
        # 'info' can fail; handle gracefully
        try:
            industry = stock.info.get('industry', 'N/A')
        except Exception:
            industry = 'N/A'
        # auto_adjust=True so Close ~ Adj Close
        hist = stock.history(period='1d', auto_adjust=True)
        if hist.empty or 'Close' not in hist:
            return f"Could not fetch price for {t}.", [], ""
        current_price = float(hist['Close'].ffill().iloc[-1])
        value = float(shares) * current_price

        conn = sqlite3.connect('portfolio_data.db')
        c = conn.cursor()
        c.execute("""INSERT INTO holdings (portfolio_id, ticker, shares, industry, current_price, value)
                     VALUES (?, ?, ?, ?, ?, ?)""",
                  (portfolio_id, t, float(shares), industry, current_price, value))
        conn.commit()

        holdings = c.execute("""SELECT industry, ticker, shares, current_price, value
                                FROM holdings WHERE portfolio_id = ?""", (portfolio_id,)).fetchall()
        conn.close()

        total_value = sum(h[4] for h in holdings) if holdings else 0.0
        if total_value <= 0:
            return f"Added {shares} shares of {t} to Portfolio", [], "Total Portfolio Value: $0.00"

        holdings_with_weights = []
        for h in holdings:
            w = (h[4] / total_value) * 100 if total_value else 0
            holdings_with_weights.append({
                'industry': h[0],
                'ticker': h[1],
                'shares': h[2],
                'current_price': round(h[3], 2),
                'value': round(h[4], 2),
                'weight': round(w, 2)
            })

        return (f"Added {shares} shares of {t} to Portfolio",
                holdings_with_weights,
                f"Total Portfolio Value: ${total_value:,.2f}")
    except Exception as e:
        return f"An error occurred: {str(e)}", [], ""


@app.callback(
    [Output('current-weights', 'children'),
     Output('current-allocation-chart', 'figure'),
     Output('optimization-results', 'children'),
     Output('allocation-chart', 'figure'),
     Output('performance-comparison-chart', 'figure')],
    Input('optimize-portfolio-btn', 'n_clicks'),
    [State('portfolio-dropdown', 'value'),
     State('risk-slider', 'value')],
    prevent_initial_call=True
)
def optimize_portfolio(n_clicks, portfolio_id, risk_level):
    if not portfolio_id:
        msg = "Please select a valid portfolio."
        return msg, go.Figure(), msg, go.Figure(), go.Figure()

    conn = sqlite3.connect('portfolio_data.db')
    c = conn.cursor()
    rows = c.execute("SELECT ticker, shares FROM holdings WHERE portfolio_id = ?", (portfolio_id,)).fetchall()
    conn.close()

    if not rows:
        msg = "No holdings to optimize."
        return msg, go.Figure(), msg, go.Figure(), go.Figure()

    tickers = [r[0].strip().upper() for r in rows]
    shares = [float(r[1]) for r in rows]
    shares_s = pd.Series(shares, index=tickers, dtype=float)

    try:
        # -------- Current weights (use latest adjusted close) --------
        last_df = fetch_price_matrix(tickers, period='5d', interval='1d')
        if last_df.empty:
            msg = "Could not fetch current prices."
            return msg, go.Figure(), msg, go.Figure(), go.Figure()

        last_prices = last_df.iloc[-1].reindex(tickers)  # align to tickers
        total_value = float((last_prices * shares_s).sum())
        if total_value <= 0:
            msg = "Portfolio value is zero; cannot compute weights."
            return msg, go.Figure(), msg, go.Figure(), go.Figure()

        current_weights = (last_prices * shares_s) / total_value
        current_weights_text = html.Ul([
            html.Li(f"{t}: {w*100:.2f}%") for t, w in current_weights.items()
        ])

        current_weights_chart = go.Figure(
            data=[go.Pie(labels=current_weights.index.tolist(),
                         values=current_weights.values, hole=.3)]
        )
        current_weights_chart.update_layout(title_text="Current Portfolio Allocation")

        # -------- Optimization (PyPortfolioOpt expects annualized mu & cov) --------
        price_hist = fetch_price_matrix(tickers, period='1y', interval='1d')
        if price_hist.empty:
            msg = "Could not fetch 1y price history for optimization."
            return msg, go.Figure(), msg, go.Figure(), go.Figure()

        mu = mean_historical_return(price_hist)                     # annualized
        S = CovarianceShrinkage(price_hist).ledoit_wolf()           # annualized

        ef = EfficientFrontier(mu, S)
        # risk_level is annualized target volatility (e.g. 0.20 = 20%)
        ef.efficient_risk(float(risk_level))
        weights = ef.clean_weights()

        # Display optimized weights
        weights_s = pd.Series(weights).reindex(price_hist.columns, fill_value=0.0)
        opt_list = [f"{t}: {w*100:.2f}%" for t, w in weights_s.items()]
        optimized_weights_text = html.Ul([html.Li(x) for x in opt_list])

        optimized_weights_chart = go.Figure(
            data=[go.Pie(labels=weights_s.index.tolist(),
                         values=weights_s.values, hole=.3)]
        )
        optimized_weights_chart.update_layout(title_text="Optimized Portfolio Allocation")

        # -------- Performance comparison --------
        # User portfolio value series
        user_portfolio = (price_hist.mul(shares_s, axis=1)).sum(axis=1)
        initial_val = float(user_portfolio.iloc[0])

        # Build an "invest initial value at t0 according to optimized weights" series
        weights_norm = weights_s / max(weights_s.sum(), 1e-12)
        dollar_alloc = weights_norm * initial_val
        opt_series = (price_hist.mul(dollar_alloc, axis=1) / price_hist.iloc[0]).sum(axis=1)

        performance_chart = go.Figure()
        performance_chart.add_trace(go.Scatter(
            x=user_portfolio.index, y=user_portfolio, mode='lines', name='User Portfolio'
        ))
        performance_chart.add_trace(go.Scatter(
            x=opt_series.index, y=opt_series, mode='lines', name='Optimized Portfolio'
        ))
        performance_chart.update_layout(
            title="Portfolio Performance Comparison",
            xaxis_title="Date", yaxis_title="Portfolio Value ($)"
        )

        return (
            current_weights_text,
            current_weights_chart,
            optimized_weights_text,
            optimized_weights_chart,
            performance_chart
        )

    except Exception as e:
        msg = f"An error occurred: {str(e)}"
        return msg, go.Figure(), msg, go.Figure(), go.Figure()


if __name__ == '__main__':
    app.run(debug=True)